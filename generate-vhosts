#!/bin/bash
LABEL_PREFIX=${1:-com.example.nginx}
TEMPLATE=${2:-/etc/swarm-gen/nginx.conf.mustache}
OUTPUT_FILE=${3:-/etc/nginx/conf.d/dynamic.conf}

if [ ! -e "${OUTPUT_FILE}" ]
then
    touch "${OUTPUT_FILE}"
fi

DOCKER_SOCK=/var/run/docker.sock

HOST_LABEL=${LABEL_PREFIX}.host
PORT_LABEL=${LABEL_PREFIX}.backend.port
UPDT_LABEL=${LABEL_PREFIX}.frontend

function swarm_force_service_reload {
	local id="${1?missing id}"
	local service=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services/${id})
	local version=$(echo ${service} | jq .Version.Index)
	local spec=$(echo ${service} | jq .Spec | jq '.TaskTemplate.ForceUpdate = 1')
	echo ${spec} | curl -s -H "Content-Type: application/json" -X POST -g -d @- --unix-socket ${DOCKER_SOCK} http://docker/services/${id}/update?version=${version} | jq .
}

function notify_containers {
	local SERVICES=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services?filters={%22label%22:[%22${UPDT_LABEL}%22]} | jq .[].Spec.Name)
	
	for SERVICE in ${SERVICES}
	do
		SERVICE=$(echo ${SERVICE} | tr -d '"')
		swarm_force_service_reload ${SERVICE}
	done
}

function get_filtered_data {
	local result=$1
	
	local request=${2?missing request}
	local filter=${3?missing filter}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/${request}?filters=${filter} | jq .)
	
	eval $result="'${content}'"
}

function get_service {
	local result=$1
	
	local id=${2?missing id}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/services/${id} | jq .)
	
	eval $result="'${content}'"
}

function generate_new_file {
	local result=$1
	local TEMP_FILE=${2?filename missing}.new
	local TEMPLATE=${3?template missing}
	local INPUT=${4?data missing}
	
	touch ${TEMP_FILE}
	
	echo ${INPUT} | mustache - ${TEMPLATE} > ${TEMP_FILE}
	
	eval $result="'${TEMP_FILE}'"
}

function get_service_data {
	local result=$1
	get_filtered_data SERVICES "services" "{%22label%22:[%22${HOST_LABEL}%22]}"
	
	local SERVICE_NAMES=$(echo $SERVICES | jq .[].Spec.Name | tr -d '"')
	
	local SERVICE_RESULT=$(echo "[]" | jq .)
	
	for SERVICE_NAME in ${SERVICE_NAMES}
	do
			local SERVICE_NAME=$(echo ${SERVICE_NAME} | tr -d '"')
			get_service SERVICE_DATA ${SERVICE_NAME}

			local SERVICE=$(echo ${SERVICE_DATA} | jq "{ name:.Spec.Name, host:.Spec.Labels[\"${HOST_LABEL}\"], port:.Spec.Labels[\"${PORT_LABEL}\"], data:. }")

			get_filtered_data HOSTS "tasks" "{%22service%22:[%22${SERVICE_NAME}%22]}"
			local HOSTS=$(echo ${HOSTS} | jq "{ tasks:[ .[] | select(.Status.State == \"running\") | { id:.ID, hostname:\"${SERVICE_NAME}.\(.Slot | tostring).\(.ID)\", data:. } ] }")
			
			local SERVICE=$(echo "[${SERVICE}, ${HOSTS}]" | jq add)
			local SERVICE_RESULT=$(echo "[ ${SERVICE_RESULT}, [ ${SERVICE} ] ]" | jq add)
	done
	
	local SERVICE_RESULT=$(echo ${SERVICE_RESULT} | jq "{services:.}")
	eval $result="'${SERVICE_RESULT}'"
}

function handle_file_change {
	local FILE1="${1?missing file1}"
	local FILE2="${2?missing file2}"
		
	local CHANGED_LINES=$(comm -3 "${FILE1}" "${FILE2}" | wc -l)
		
	if [ ${CHANGED_LINES} -gt 0 ]
	then
		echo "Configuration updated."
		mv -f "${FILE1}" "${FILE2}"
		notify_containers
	else
		echo "Configuration unchanged."
		rm "${FILE1}"
	fi
}

function cleanup {
	exit 0
}

trap cleanup SIGINT SIGTERM

while [ 1 ]
do
	get_service_data DATA
		
	generate_new_file NEW_FILE ${OUTPUT_FILE} ${TEMPLATE} "${DATA}"

	handle_file_change ${NEW_FILE} ${OUTPUT_FILE}
	
	sleep 5
done
