#!/bin/bash
LABEL_PREFIX=${1:-com.example}
GENERATOR=${2:-haproxy}
MYSQL_HOST=${MYSQL_HOST:-disabled}
HOSTMASTER=${HOSTMASTER:-disabled}

if [ "${MYSQL_HOST}" != "disabled" ]
then
	MYSQL_USER=${MYSQL_USER?user missing}
	MYSQL_PASS=${MYSQL_PASS?pass missing}
	MYSQL_DB=${MYSQL_DB?db missing}
fi

DOCKER_SOCK=/var/run/docker.sock

ROOT_LABEL=${LABEL_PREFIX}.${GENERATOR}

FRNT_LABEL=${ROOT_LABEL}.frontend

BKNT_LABEL=${ROOT_LABEL}.backend
PORT_LABEL=${BKNT_LABEL}.port

HOST_LABEL=${ROOT_LABEL}.host
SLCT_LABEL=${HOST_LABEL}.primary

if [ "${GENERATOR}" == "haproxy" ]
then
	CERTSTORE=/usr/local/etc/haproxy/certificates
else
	CERTSTORE=/etc/nginx/certificates
fi

function swarm_force_service_reload {
	local id="${1?missing id}"
	get_service service ${id}
	local version=$(echo ${service} | jq .Version.Index)
	local spec=$(echo ${service} | jq .Spec | jq '.TaskTemplate.ForceUpdate = 1')
	echo ${spec} | curl -s -H "Content-Type: application/json" -X POST -g -d @- --unix-socket ${DOCKER_SOCK} http://docker/services/${id}/update?version=${version} | jq .
}

function notify_containers {
	local SERVICES=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services?filters={%22label%22:[%22${FRNT_LABEL}%22]} | jq .[].Spec.Name)
	
	for SERVICE in ${SERVICES}
	do
		SERVICE=$(echo ${SERVICE} | tr -d '"')
		swarm_force_service_reload ${SERVICE}
	done
	
	sleep 30 # Waiting for service update...
}

function get_filtered_data {
	local result=$1
	
	local request=${2?missing request}
	local filter=${3?missing filter}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/${request}?filters=${filter} | jq .)
	
	eval $result="'${content}'"
}

function get_service {
	local result=$1
	
	local id=${2?missing id}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/services/${id} | jq .)
	
	eval $result="'${content}'"
}

function generate_new_file {
	local result=$1
	local TEMP_FILE=${2?filename missing}.new
	local TEMPLATE=${3?template missing}
	local INPUT=${4?data missing}
	
	touch ${TEMP_FILE}
	
	echo ${INPUT} | mustache - ${TEMPLATE} > ${TEMP_FILE}
	
	eval $result="'${TEMP_FILE}'"
}

function get_service_data {
	local result=$1
	get_filtered_data SERVICES "services" "{%22label%22:[%22${SLCT_LABEL}%22]}"
	
	local SERVICE_NAMES=$(echo $SERVICES | jq .[].Spec.Name | tr -d '"')
	
	local SERVICE_RESULT=$(echo "[]" | jq .)
	
	for SERVICE_NAME in ${SERVICE_NAMES}
	do
			local SERVICE_NAME=$(echo ${SERVICE_NAME} | tr -d '"')
			get_service SERVICE_DATA ${SERVICE_NAME}

			local SERVICE=$(echo ${SERVICE_DATA} | jq "
def process(f):
	if (f | type == \"array\") then 
		[ 
			f | 
			group_by(.key[0])[] | 
			if (try (.[0].key[0] | tonumber) catch -1) == -1 then
				if (. | length == 1) then 
					{ key: .[0].key[0], value: .[0].value }
				else
					{ key: .[0].key[0], value: process( [ .[] | { key: .key[1:], value: .value } ] ) | ( if ( try from_entries catch -1 ) == -1 then . else from_entries end ) }
				end
			else
				process( [ .[] | { key: .key[1:], value: .value } ] ) | ( try from_entries catch . )
			end
		]
	else 
		.
	end;

			{ 
				name:.Spec.Name,
				labels: [ .Spec.Labels | to_entries[] | select( .key | startswith(\"${LABEL_PREFIX}.\") ) | .key |= ( . | ltrimstr(\"${LABEL_PREFIX}.\") | split(\".\") ) ] | process(.) | from_entries,
				data:. 
			}")

			get_filtered_data HOSTS "tasks" "{%22service%22:[%22${SERVICE_NAME}%22]}"
			local HOSTS=$(echo ${HOSTS} | jq "{ tasks:[ .[] | select(.Status.State == \"running\") | { id:.ID, hostname:\"${SERVICE_NAME}.\(.Slot | tostring).\(.ID)\", data:. } ] }")
			
			local SERVICE=$(echo "[${SERVICE}, ${HOSTS}]" | jq add)
			local SERVICE=$(echo "${SERVICE}" | jq ".isActive = ((.tasks | length) != 0)")
			local SERVICE_RESULT=$(echo "[ ${SERVICE_RESULT}, [ ${SERVICE} ] ]" | jq add)
	done
	
	local CERTHOST=$(hostname)
	
	if [ "$(ls ${CERTSTORE} | wc -l)" == 0 ]
	then
		local ENABLE_SSL=false
	else
		local ENABLE_SSL=true
	fi
	local SERVICE_RESULT=$(echo ${SERVICE_RESULT} | jq "{services:., enableSSL:${ENABLE_SSL}, certhost:\"${CERTHOST}\", recordtag:\"${ROOT_LABEL}\"}")
	eval $result="'${SERVICE_RESULT}'"
}

function update_dns {
	if [ "${MYSQL_HOST}" != "disabled" ]
	then
		local TEMPLATE=/etc/swarm-gen/updatepdns.sql.mustache
		local OUTPUT=/etc/swarm-gen/updatepdns.sql
		
		generate_new_file NEW_CONF ${OUTPUT} ${TEMPLATE} "${DATA}"

		handle_file_change CHANGED ${NEW_CONF} ${OUTPUT}

		if [ "${CHANGED}" != "0" ]
		then
			echo "Updateing PowerDNS"
			mysql --host="${MYSQL_HOST}" --user="${MYSQL_USER}" --password="${MYSQL_PASS}" --database="${MYSQL_DB}" < ${OUTPUT}
		else
			echo "Skiping PowerDNS update"
		fi
	fi
}

function handle_file_change {
	local result=$1
	
	local FILE1="${2?missing file1}"
	local FILE2="${3?missing file2}"
	
	touch ${FILE1}
	touch ${FILE2}
		
	local CHANGED_LINES=$(comm -3 "${FILE1}" "${FILE2}" | wc -l)
		
	if [ ${CHANGED_LINES} -gt 0 ]
	then
		mv -f "${FILE1}" "${FILE2}"
		eval $result=1
	else
		rm "${FILE1}"
		eval $result=0
	fi
}

function handle_nginx {
	local TEMPLATE=/etc/swarm-gen/nginx.conf.mustache
	local OUTPUT_FILE=/etc/nginx/conf.d/hosts.conf
	
	generate_new_file NEW_FILE ${OUTPUT_FILE} ${TEMPLATE} "${DATA}"
	
	handle_file_change CHANGED ${NEW_FILE} ${OUTPUT_FILE}
	
	if [ "${CHANGED}" != "0" ]
	then
		echo "Configuration updated."
		notify_containers
	else
		echo "Configuration unchanged."
	fi
}

function handle_haproxy {
	local TEMPLATE_CONF=/etc/swarm-gen/haproxy.cfg.mustache
	local TEMPLATE_MAP=/etc/swarm-gen/host.map.mustache
	local OUTPUT_CONF=/usr/local/etc/haproxy/haproxy.cfg
	local OUTPUT_MAP=/usr/local/etc/haproxy/host.map
	
	generate_new_file NEW_CONF ${OUTPUT_CONF} ${TEMPLATE_CONF} "${DATA}"
	generate_new_file NEW_MAP ${OUTPUT_MAP} ${TEMPLATE_MAP} "${DATA}"
		
	cp /etc/swarm-gen/*.http /usr/local/etc/haproxy/
	
	handle_file_change CONF_CHANGED ${NEW_CONF} ${OUTPUT_CONF}
	handle_file_change MAP_CHANGED ${NEW_MAP} ${OUTPUT_MAP}
	
	if [ "${CONF_CHANGED}" != "0" ] || [ "${MAP_CHANGED}" != "0" ]
	then
		echo "Configuration updated."
		notify_containers
	else
		echo "Configuration unchanged."
	fi
}

function join_by { local IFS="$1"; shift; echo "$*"; }

function update_certificates {
	if [ "${HOSTMASTER}" != "disabled" ]
	then
		local TEMPLATE=/etc/swarm-gen/domainlist.mustache
		local OUTPUT=/etc/swarm-gen/domainlist

		generate_new_file NEW_FILE "${OUTPUT}" "${TEMPLATE}" "${DATA}"

		handle_file_change CHANGED "${NEW_FILE}" "${OUTPUT}"
		
		if [ "${CHANGED}" != "0" ]
		then	
			echo "Generating certificates"
			
			mapfile -t requests <<< $(cat ${OUTPUT})
			
			for entries in "${requests[@]}"
			do
				local entry=(${entries})
				local DOMAINS=$(for k in "${entry[@]}"; do echo "-d ${k}"; done)
				local DOMAINS=$(join_by " " ${DOMAINS})
				certbot certonly --noninteractive --agree-tos --standalone --http-01-port 80 --preferred-challenges http --email \"${HOSTMASTER}\" --expand ${DOMAINS}
			done
			
			rm -rf ${CERTSTORE}/*
			
			if [ -d /etc/letsencrypt/live ]
				then
				
				for entries in "${requests[@]}"
				do
					local entry=(${entries})
					local folder="/etc/letsencrypt/live/${entry[0]}"
					if [ -d "${folder}" ]
					then
						local newpath="${CERTSTORE}/${entry[0]}"
						cat ${folder}/fullchain.pem ${folder}/privkey.pem > ${newpath}
					fi
				done
			else
				rm ${OUTPUT}
			fi
		fi
	fi
}

function cleanup { exit 0; }

trap cleanup SIGINT SIGTERM

while [ 1 ]
do
	mkdir -p ${CERTSTORE}

	get_service_data DATA
		
	update_dns
	
	if [ "${GENERATOR}" == "haproxy" ]
	then
		handle_haproxy
	else
		handle_nginx
	fi
	
	update_certificates
	
	sleep 30
done
