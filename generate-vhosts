#!/bin/bash
LABEL_PREFIX=${1:-com.example.nginx}

OUTPUT_FILE=${2:-/etc/nginx/conf.d/dynamic.conf}

if [ ! -e "${OUTPUT_FILE}" ]
then
    touch "${OUTPUT_FILE}"
fi

DOCKER_SOCK=/var/run/docker.sock

HOST_LABEL=${LABEL_PREFIX}.host
PORT_LABEL=${LABEL_PREFIX}.backend.port
UPDT_LABEL=${LABEL_PREFIX}.frontend

function swarm_force_service_reload {
	local id="${1?missing id}"
	local service=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services/${id})
	local version=$(echo ${service} | jq .Version.Index)
	local spec=$(echo ${service} | jq .Spec | jq '.TaskTemplate.ForceUpdate = 1')
	echo ${spec} | curl -s -H "Content-Type: application/json" -X POST -g -d @- --unix-socket ${DOCKER_SOCK} http://docker/services/${id}/update?version=${version} | jq .
}

function notify_containers {
	local SERVICES=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services?filters={%22label%22:[%22${UPDT_LABEL}%22]} | jq .[].Spec.Name)
	
	for SERVICE in ${SERVICES}
	do
		SERVICE=$(echo ${SERVICE} | tr -d '"')
		swarm_force_service_reload ${SERVICE}
	done
}

function generate_new_file {
	local result=$1
	
	local SERVICES=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services?filters={%22label%22:[%22${HOST_LABEL}%22]} | jq .)
	local SERVICE_NAMES=$(echo $SERVICES | jq .[].Spec.Name)

	local TEMP_FILE=${2?filename missing}.new
	touch ${TEMP_FILE}
	echo "# Generated by rwindegger/swarm-gen" > ${TEMP_FILE}

	for SERVICE_NAME in ${SERVICE_NAMES}
	do
			local SERVICE_NAME=$(echo ${SERVICE_NAME} | tr -d '"')

			local VHOST=$(echo ${SERVICES} | jq ".[] | select(.Spec.Name == \"${SERVICE_NAME}\") | .Spec.Labels[\"${HOST_LABEL}\"]" | tr -d '"')
			local PORT=$(echo ${SERVICES} | jq ".[] | select(.Spec.Name == \"${SERVICE_NAME}\") | .Spec.Labels[\"${PORT_LABEL}\"]" | tr -d '"')

			local HOSTS=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/tasks?filters={%22service%22:[%22${SERVICE_NAME}%22]} | jq "[.[] | select(.Status.State == \"running\") | {id:.ID, slot:.Slot, state:.Status.State, data:.}]")
			local HOST_NAMES=$(echo "${HOSTS}" | jq ".[] | \"${SERVICE_NAME}.\" + (.slot | tostring) + \".\" + .id" | tr -d '"')

			echo "upstream ${SERVICE_NAME} {" >> ${TEMP_FILE}

			for HOST_NAME in ${HOST_NAMES}
			do
					echo "  server ${HOST_NAME}:${PORT};" >> ${TEMP_FILE}
			done

			echo "}" >> ${TEMP_FILE}

			echo "server {" >> ${TEMP_FILE}

			echo "  server_name ${VHOST};" >> ${TEMP_FILE}
			echo "  listen 80;" >> ${TEMP_FILE}
			echo "  access_log /var/log/nginx/access.log vhost;" >> ${TEMP_FILE}
			echo "  location / {" >> ${TEMP_FILE}
			echo "          proxy_pass http://${SERVICE_NAME}" >> ${TEMP_FILE}
			echo "  }" >> ${TEMP_FILE}

			echo "}" >> ${TEMP_FILE}
	done
	
	eval $result="'${TEMP_FILE}'"
}

function handle_file_change {
	local FILE1="${1?missing file1}"
	local FILE2="${2?missing file2}"
		
	local CHANGED_LINES=$(comm -3 "${FILE1}" "${FILE2}" | wc -l)
		
	if [ ${CHANGED_LINES} -gt 0 ]
	then
		echo "Configuration updated."
		mv -f "${FILE1}" "${FILE2}"
		notify_containers
	else
		echo "Configuration unchanged."
		rm "${FILE1}"
	fi
}

function cleanup {
	exit 0
}

trap cleanup SIGINT SIGTERM

while [ 1 ]
do
	generate_new_file NEW_FILE ${OUTPUT_FILE}

	handle_file_change ${NEW_FILE} ${OUTPUT_FILE}
	
	sleep 5
done
