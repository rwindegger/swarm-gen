#!/bin/bash
LABEL_PREFIX=${1:-com.example}
GENERATOR=${2:-haproxy}

MYSQL_HOST=${MYSQL_HOST:-disabled}

HOSTMASTER=${HOSTMASTER?hostmaster missing}

CERTSTORE=/usr/local/etc/haproxy/certificates
mkdir -p ${CERTSTORE}

if [ "${MYSQL_HOST}" != "disabled" ]
then
	MYSQL_USER=${MYSQL_USER?user missing}
	MYSQL_PASS=${MYSQL_PASS?pass missing}
	MYSQL_DB=${MYSQL_DB?db missing}
fi

DOCKER_SOCK=/var/run/docker.sock

ROOT_LABEL=${LABEL_PREFIX}.${GENERATOR}
ENDP_LABEL=${ROOT_LABEL}.host.endpoint
DOMN_LABEL=${ROOT_LABEL}.host.domain
HOST_LABEL=${ROOT_LABEL}.host
PORT_LABEL=${ROOT_LABEL}.backend.port
UPDT_LABEL=${ROOT_LABEL}.frontend

function swarm_force_service_reload {
	local id="${1?missing id}"
	get_service service ${id}
	local version=$(echo ${service} | jq .Version.Index)
	local spec=$(echo ${service} | jq .Spec | jq '.TaskTemplate.ForceUpdate = 1')
	echo ${spec} | curl -s -H "Content-Type: application/json" -X POST -g -d @- --unix-socket ${DOCKER_SOCK} http://docker/services/${id}/update?version=${version} | jq .
}

function notify_containers {
	local SERVICES=$(curl -s -g --unix-socket ${DOCKER_SOCK} http://docker/services?filters={%22label%22:[%22${UPDT_LABEL}%22]} | jq .[].Spec.Name)
	
	for SERVICE in ${SERVICES}
	do
		SERVICE=$(echo ${SERVICE} | tr -d '"')
		swarm_force_service_reload ${SERVICE}
	done
}

function get_filtered_data {
	local result=$1
	
	local request=${2?missing request}
	local filter=${3?missing filter}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/${request}?filters=${filter} | jq .)
	
	eval $result="'${content}'"
}

function get_service {
	local result=$1
	
	local id=${2?missing id}
	
	local content=$(curl -sg --unix-socket ${DOCKER_SOCK} http://docker/services/${id} | jq .)
	
	eval $result="'${content}'"
}

function generate_new_file {
	local result=$1
	local TEMP_FILE=${2?filename missing}.new
	local TEMPLATE=${3?template missing}
	local INPUT=${4?data missing}
	
	touch ${TEMP_FILE}
	
	echo ${INPUT} | mustache - ${TEMPLATE} > ${TEMP_FILE}
	
	eval $result="'${TEMP_FILE}'"
}

function get_service_data {
	local result=$1
	get_filtered_data SERVICES "services" "{%22label%22:[%22${HOST_LABEL}%22]}"
	
	local SERVICE_NAMES=$(echo $SERVICES | jq .[].Spec.Name | tr -d '"')
	
	local SERVICE_RESULT=$(echo "[]" | jq .)
	
	for SERVICE_NAME in ${SERVICE_NAMES}
	do
			local SERVICE_NAME=$(echo ${SERVICE_NAME} | tr -d '"')
			get_service SERVICE_DATA ${SERVICE_NAME}

			local SERVICE=$(echo ${SERVICE_DATA} | jq "{ name:.Spec.Name, domain:.Spec.Labels[\"${DOMN_LABEL}\"], endpoint:.Spec.Labels[\"${ENDP_LABEL}\"], host:.Spec.Labels[\"${HOST_LABEL}\"], port:.Spec.Labels[\"${PORT_LABEL}\"], data:. }")

			get_filtered_data HOSTS "tasks" "{%22service%22:[%22${SERVICE_NAME}%22]}"
			local HOSTS=$(echo ${HOSTS} | jq "{ tasks:[ .[] | select(.Status.State == \"running\") | { id:.ID, hostname:\"${SERVICE_NAME}.\(.Slot | tostring).\(.ID)\", data:. } ] }")
			
			local SERVICE=$(echo "[${SERVICE}, ${HOSTS}]" | jq add)
			local SERVICE=$(echo "${SERVICE}" | jq ".isActive = ((.tasks | length) != 0)")
			local SERVICE_RESULT=$(echo "[ ${SERVICE_RESULT}, [ ${SERVICE} ] ]" | jq add)
	done
	
	local CERTHOST=$(hostname)
	local ENABLE_SSL=$(ls ${CERTSTORE} | wc -l)
	local SERVICE_RESULT=$(echo ${SERVICE_RESULT} | jq "{services:., enableSSL:${ENABLE_SSL}, certhost:\"${CERTHOST}\", recordtag:\"${ROOT_LABEL}\"}")
	eval $result="'${SERVICE_RESULT}'"
}

function update_dns {
	if [ "${MYSQL_HOST}" != "disabled" ]
	then
		local TEMPLATE=/etc/swarm-gen/updatepdns.sql.mustache
		local OUTPUT=/etc/swarm-gen/updatepdns.sql
		
		generate_new_file NEW_CONF ${OUTPUT} ${TEMPLATE} "${DATA}"
		
		handle_file_change CHANGED ${NEW_CONF} ${OUTPUT}
		
		if [ "${CHANGED}" != "0" ]
		then
			echo "Updateing PowerDNS"
			mysql --host="${MYSQL_HOST}" --user="${MYSQL_USER}" --password="${MYSQL_PASS}" --database="${MYSQL_DB}" < ${OUTPUT}
		else
			echo "Skiping PowerDNS update"
		fi
	fi
}

function handle_file_change {
	local result=$1
	
	local FILE1="${2?missing file1}"
	local FILE2="${3?missing file2}"
	
	touch ${FILE1}
	touch ${FILE2}
		
	local CHANGED_LINES=$(comm -3 "${FILE1}" "${FILE2}" | wc -l)
		
	if [ ${CHANGED_LINES} -gt 0 ]
	then
		mv -f "${FILE1}" "${FILE2}"
		eval $result=1
	else
		rm "${FILE1}"
		eval $result=0
	fi
}

function cleanup {
	exit 0
}

function handle_nginx {
	local TEMPLATE=/etc/swarm-gen/nginx.conf.mustache
	local OUTPUT_FILE=/etc/nginx/conf.d/hosts.conf
	
	generate_new_file NEW_FILE ${OUTPUT_FILE} ${TEMPLATE} "${DATA}"
	
	handle_file_change CHANGED ${NEW_FILE} ${OUTPUT_FILE}
	
	if [ "${CHANGED}" != "0" ]
	then
		echo "Configuration updated."
		notify_containers
	else
		echo "Configuration unchanged."
	fi
}

function handle_haproxy {
	local TEMPLATE_CONF=/etc/swarm-gen/haproxy.cfg.mustache
	local TEMPLATE_MAP=/etc/swarm-gen/host.map.mustache
	local OUTPUT_CONF=/usr/local/etc/haproxy/haproxy.cfg
	local OUTPUT_MAP=/usr/local/etc/haproxy/host.map
	
	generate_new_file NEW_CONF ${OUTPUT_CONF} ${TEMPLATE_CONF} "${DATA}"
	generate_new_file NEW_MAP ${OUTPUT_MAP} ${TEMPLATE_MAP} "${DATA}"
	
	cp /etc/swarm-gen/*.http /usr/local/etc/haproxy/
	
	handle_file_change CONF_CHANGED ${NEW_CONF} ${OUTPUT_CONF}
	handle_file_change MAP_CHANGED ${NEW_MAP} ${OUTPUT_MAP}
	
	if [ "${CONF_CHANGED}" != "0" ] || [ "${MAP_CHANGED}" != "0" ]
	then
		echo "Configuration updated."
		notify_containers
	else
		echo "Configuration unchanged."
	fi
}

function update_certificates {
	local TEMPLATE=/etc/swarm-gen/domainlist.mustache
	local OUTPUT=/etc/swarm-gen/domainlist

	generate_new_file NEW_FILE ${OUTPUT} ${TEMPLATE} "${DATA}"
	
	handle_file_change CHANGED ${NEW_FILE} ${OUTPUT}
	
	if [ "${CHANGED}" != "0" ]
	then	
		echo "Generating a new certificate"
		cat ${OUTPUT} | parallel --jobs 1 -X certbot certonly --noninteractive --agree-tos --standalone --http-01-port=80 --preferred-challenges=http --email="${HOSTMASTER}" --domain={}
		
		if [ "${GENERATOR}" == "haproxy" ]
		then
			rm -rf ${CERTSTORE}/*
			
			cd /etc/letsencrypt/live
			for f in */fullchain.pem
			do
				folder="${f%/*}"
				newpath="${CERTSTORE}/${folder}.pem"
				cat ${folder}/fullchain.pem ${folder}/privkey.pem > ${newpath}
			done
			cd -
		fi
	fi
}

trap cleanup SIGINT SIGTERM

while [ 1 ]
do
	get_service_data DATA
	
	update_dns
	
	if [ "${GENERATOR}" == "haproxy" ]
	then
		handle_haproxy
		update_certificates
	else
		handle_nginx
	fi
	
	sleep 5
done
